import sys
import os
import shutil
import requests
import subprocess
import zipfile
import py7zr
import rarfile
import json
import configparser
import traceback
import psutil
import time
import logging
import tkinter as tk
from tkinter import ttk, colorchooser, messagebox, filedialog
import subprocess
from packaging import version

settings_file = "settings.json"

def preserve_custom_tga_files(zeal_dir):
    """Preserves custom TGA files from the targetrings folder during Zeal updates."""
    try:
        targetrings_path = os.path.join(zeal_dir, 'uifiles', 'zeal', 'targetrings')
        
        if not os.path.exists(targetrings_path):
            return None  # No files to preserve
            
        preserved_files = {}
        if os.path.exists(targetrings_path):
            for file in os.listdir(targetrings_path):
                if file.lower().endswith('.tga'):
                    file_path = os.path.join(targetrings_path, file)
                    with open(file_path, 'rb') as f:
                        preserved_files[file] = f.read()
        
        return preserved_files
        
    except Exception as e:
        log_message(f"Error preserving TGA files: {str(e)}", "red")
        return None

def restore_custom_tga_files(zeal_dir, preserved_files):
    """Restores preserved TGA files after Zeal update."""
    if not preserved_files:
        return
        
    try:
        targetrings_path = os.path.join(zeal_dir, 'uifiles', 'zeal', 'targetrings')
        os.makedirs(targetrings_path, exist_ok=True)
        
        current_files = set()
        if os.path.exists(targetrings_path):
            current_files = {f.lower() for f in os.listdir(targetrings_path) if f.lower().endswith('.tga')}
        
        restored_count = 0
        for filename, content in preserved_files.items():
            if filename.lower() not in current_files:
                file_path = os.path.join(targetrings_path, filename)
                with open(file_path, 'wb') as f:
                    f.write(content)
                restored_count += 1
        
        if restored_count > 0:
            log_message(f"Restored {restored_count} custom TGA files", "green")
            
    except Exception as e:
        log_message(f"Error restoring TGA files: {str(e)}", "red")

class CustomDropdown(tk.Frame):
    def __init__(self, master, variable, values, **kwargs):
        super().__init__(master)
        self.variable = variable
        self.values = values

        self.entry = tk.Entry(self, textvariable=self.variable, width=15, justify='center')
        self.entry.pack(side='left', fill='x', expand=True)

        self.button = tk.Button(self, text='▼', command=self.show_dropdown, width=3)
        self.button.pack(side='left')

        self.dropdown = tk.Menu(self, tearoff=0)
        for value in self.values:
            self.dropdown.add_command(label=value, command=lambda v=value: self.select_value(v))

    def show_dropdown(self):
        x = self.button.winfo_rootx()
        y = self.button.winfo_rooty() + self.button.winfo_height()
        self.dropdown.post(x, y)

    def select_value(self, value):
        self.variable.set(value)

class UIInstallationStatus(tk.Toplevel):
    def __init__(self, parent):
        super().__init__(parent)
        self.title("UI Installation Status")
        self.geometry("300x200")
        self.transient(parent)
        self.grab_set()

        self.status_text = tk.Text(self, wrap=tk.WORD, width=40, height=10)
        self.status_text.pack(padx=10, pady=10, expand=True, fill=tk.BOTH)

        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(self, variable=self.progress_var, maximum=100)
        self.progress_bar.pack(padx=10, pady=10, fill=tk.X)

    def update_status(self, message):
        self.status_text.insert(tk.END, message + "\n")
        self.status_text.see(tk.END)
        self.update()

    def update_progress(self, value):
        self.progress_var.set(value)
        self.update()

class ShortcutsDialog(tk.Toplevel):
    def __init__(self, parent):
        super().__init__(parent)
        self.title("Shortcuts Applied")
        
        # Configure window
        self.geometry("300x280")
        self.resizable(False, False)
        self.configure(bg="white")
        self.transient(parent)
        self.grab_set()
        
        # Remove window decorations except title bar and close button
        if sys.platform == "win32":
            self.attributes("-toolwindow", True)
        
        # Create main container
        main_frame = tk.Frame(self, bg="white", padx=20, pady=15)
        main_frame.pack(expand=True, fill="both")
        
        # Title with icon
        title_frame = tk.Frame(main_frame, bg="white")
        title_frame.pack(fill="x", pady=(0, 10))
        
        icon_label = tk.Label(title_frame, text="⚙️", bg="white", font=("Segoe UI", 16))
        icon_label.pack(side="left", padx=(0, 8))
        
        title_label = tk.Label(title_frame, text="Shortcuts Applied", 
                             bg="white", font=("Segoe UI", 12, "bold"))
        title_label.pack(side="left")
        
        # "Changed:" label
        changed_label = tk.Label(main_frame, text="Changed:", 
                               bg="white", font=("Segoe UI", 10))
        changed_label.pack(anchor="w", pady=(0, 5))
        
        # Shortcuts list
        shortcuts = [
            ("WASD", "keys to move"),
            ("Q", "to auto-attack"),
            ("E", "to duck"),
            ("\\", "to auto-run"),
            ("TAB", "to cycle nearby NPCs"),
            ("`", "to cycle PCs"),
            ("B", "to open all containers")
        ]
        
        for key, action in shortcuts:
            shortcut_frame = tk.Frame(main_frame, bg="white")
            shortcut_frame.pack(fill="x", pady=2)
            
            key_label = tk.Label(shortcut_frame, text=key,
                               bg="white", font=("Segoe UI", 9, "bold"))
            key_label.pack(side="left")
            
            action_label = tk.Label(shortcut_frame, text=f" {action}",
                                  bg="white", font=("Segoe UI", 9))
            action_label.pack(side="left")
        
        # OK button
        button_style = {
            'font': ('Segoe UI', 10),
            'fg': 'white',
            'bg': '#0078D4',
            'activebackground': '#106EBE',
            'activeforeground': 'white',
            'relief': 'flat',
            'width': 10
        }
        
        ok_button = tk.Button(main_frame, text="OK", 
                            command=self.destroy, **button_style)
        ok_button.pack(pady=(15, 0))
        
        # Center the window on screen
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'+{x}+{y}')

class AdvancedConfiguratorWindow(tk.Toplevel):
    def __init__(self, parent, zeal_dir):
        super().__init__(parent)
        self.title("Advanced Configurator")
        self.zeal_dir = zeal_dir
        self.parent = parent
        self.settings = {
            'WindowedMode': 'bool',
            'NewUI': 'bool',
            'OldUI': 'bool',
            'Log': 'bool',
            'CombatMusic': 'bool',
            'AttackOnAssist': 'bool',
            'EnableBrownSkeletonHack': 'bool',
            'EnableExtendedNameplateDistance': 'bool',
            'BitsPerPixel': 'int',
            'Width': 'int',
            'Height': 'int',
            'RefreshRate': 'int',
            'MaxFPS': 'int',
            'MaxBGFPS': 'int',
            'MaxMouseLookFPS': 'int',
            'NoFPSLimiter': 'bool',
            'ChatTimestamps': 'dropdown',
            'Bluecon': 'bool',
            'ZealInput': 'bool',
            'FloatingDamage': 'bool',
            'UseUmbra': 'dropdown'
        }
        self.chat_timestamp_options = {
            'None': 1,
            'Short': 2,
            'Long': 3
        }
        self.nofpslimiter_options = {
            'On (recommended)': 1,
            'Off': 0,
        }
        self.useumbra_options = {
            'TRUE': 'TRUE',
            'FALSE': 'FALSE'
        }

        try:
            self.current_settings = self.load_current_settings()
            print("Current settings loaded successfully")
        except Exception as e:
            print(f"Error loading current settings: {str(e)}")
            print(traceback.format_exc())
        
        try:
            self.create_widgets()
            print("Widgets created successfully")
        except Exception as e:
            print(f"Error creating widgets: {str(e)}")
            print(traceback.format_exc())
        
        self.setup_mousewheel_binding()
        self.update_idletasks()
        self.geometry(f"{self.winfo_reqwidth()}x{self.winfo_reqheight()}+{parent.winfo_x()+parent.winfo_width()+10}+{parent.winfo_y()}")
        self.transient(parent)
        self.grab_set()
        self.protocol("WM_DELETE_WINDOW", self.on_closing)

    def create_widgets(self):
        # Create main frame
        main_frame = tk.Frame(self)
        main_frame.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

        # Create canvas and scrollbar
        self.canvas = tk.Canvas(main_frame)
        scrollbar = tk.Scrollbar(main_frame, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = tk.Frame(self.canvas)

        # Configure scrollable frame
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        )

        # Create window inside canvas
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=scrollbar.set)

        # Create widgets dictionary
        self.widgets = {}
        
        # Add settings widgets
        for setting, type_ in self.settings.items():
            frame = tk.Frame(self.scrollable_frame)
            frame.pack(fill=tk.X, padx=5, pady=5)
            
            label = tk.Label(frame, text=f"{setting}:")
            label.pack(side=tk.LEFT)

            if type_ == 'bool':
                var = tk.BooleanVar(value=self.current_settings.get(setting, False))
                widget = tk.Checkbutton(frame, variable=var)
            elif type_ == 'dropdown' and setting == 'ChatTimestamps':
                var = tk.StringVar(value=self.get_chat_timestamp_key(self.current_settings.get(setting, 1)))
                widget = CustomDropdown(frame, var, list(self.chat_timestamp_options.keys()))
                widget.config(width=150, height=30)
            elif type_ == 'dropdown' and setting == 'NoFPSLimiter':
                var = tk.StringVar(value=self.get_nofpslimiter_key(self.current_settings.get(setting, 1)))
                widget = CustomDropdown(frame, var, list(self.nofpslimiter_options.keys()))
                widget.config(width=150, height=20)
            elif type_ == 'dropdown' and setting == 'UseUmbra':
                var = tk.StringVar(value=self.current_settings.get(setting, 'TRUE'))
                widget = CustomDropdown(frame, var, list(self.useumbra_options.keys()))
                widget.config(width=150, height=20)
            else:
                var = tk.StringVar(value=str(self.current_settings.get(setting, '')))
                widget = tk.Entry(frame, textvariable=var, width=10)

            widget.pack(side=tk.RIGHT, padx=(0, 10))
            self.widgets[setting] = var

            if setting == 'Bluecon':
                self.bluecon_var = var
                self.bluecon_var.trace('w', self.toggle_color_picker)
                self.color_button = tk.Button(frame, text="Choose Color", command=self.choose_color)
                self.color_button.pack(side=tk.RIGHT, padx=(0, 10))
                self.toggle_color_picker()

        # Add apply button
        apply_button = tk.Button(self.scrollable_frame, text="Apply Settings", command=self.apply_settings)
        apply_button.pack(pady=10)

        # Pack canvas and scrollbar
        self.canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

    def get_nofpslimiter_key(self, value):
        return next((k for k, v in self.nofpslimiter_options.items() if v == value), 'On (recommended)')

    def setup_mousewheel_binding(self):
        def _on_mousewheel(event):
            self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        self.canvas.bind_all("<MouseWheel>", _on_mousewheel)

    def load_current_settings(self):
        eqclient_path = os.path.join(self.zeal_dir, 'eqclient.ini')
        config = configparser.ConfigParser()
        config.optionxform = str
        config.read(eqclient_path)
        settings = {}
        for section in config.sections():
            for key in self.settings:
                if config.has_option(section, key):
                    value = config.get(section, key)
                    if self.settings[key] == 'bool':
                        settings[key] = value.lower() == 'true'
                    elif self.settings[key] == 'int':
                        settings[key] = int(value) if value.isdigit() else 0
        if 'Bluecon' in settings and settings['Bluecon']:
            for color in ['Red', 'Green', 'Blue']:
                key = f'User_70_{color}'
                if config.has_option(section, key):
                    settings[key] = int(config.get(section, key))
        return settings

    def toggle_color_picker(self, *args):
        if self.bluecon_var.get():
            self.color_button.pack(side=tk.RIGHT, padx=(0, 10))
        else:
            self.color_button.pack_forget()

    def choose_color(self):
        self.attributes('-topmost', True)
        color = colorchooser.askcolor(title="Choose color", parent=self)
        self.attributes('-topmost', False)
        if color[1]:
            r, g, b = [int(x) for x in color[0]]
            self.widgets['User_70_Red'] = tk.IntVar(value=r)
            self.widgets['User_70_Green'] = tk.IntVar(value=g)
            self.widgets['User_70_Blue'] = tk.IntVar(value=b)
            self.color_button.config(bg=color[1])

    def get_chat_timestamp_key(self, value):
        return next((k for k, v in self.chat_timestamp_options.items() if v == value), 'None')

    def apply_settings(self):
        eqclient_path = os.path.join(self.zeal_dir, 'eqclient.ini')
        if not os.path.exists(eqclient_path):
            messagebox.showerror("Error", "eqclient.ini file not found in the selected directory.")
            return

        config = configparser.ConfigParser()
        config.optionxform = str
        config.read(eqclient_path)

        if 'Defaults' not in config.sections():
            config.add_section('Defaults')

        for section in config.sections():
            for setting, var in self.widgets.items():
                if config.has_option(section, setting) or setting == 'UseUmbra':
                    value = var.get()
                    if isinstance(value, bool):
                        value = 'TRUE' if value else 'FALSE'
                    elif setting == 'ChatTimestamps':
                        value = str(self.chat_timestamp_options[value])
                    elif setting == 'UseUmbra':
                        config.set('Defaults', 'UseUmbra', value)
                        continue
                    
                    if setting != 'UseUmbra':
                        config.set(section, setting, str(value))

        if 'Options' not in config.sections():
            config.add_section('Options')
        no_fps_limiter_value = '1' if self.widgets['NoFPSLimiter'].get() == 'On (recommended)' else '0'
        config.set('Options', 'NoFPSLimiter', no_fps_limiter_value)

        with open(eqclient_path, 'w') as configfile:
            config.write(configfile)

        messagebox.showinfo("Settings Applied", "Your settings have been applied successfully.")
        self.destroy()

    def on_closing(self):
        self.parent.focus_set()
        self.destroy()

def apply_wasd_shortcuts():
    zeal_dir = zeal_dir_entry.get()
    if not zeal_dir:
        messagebox.showerror("Error", "Please select your Zeal directory first.")
        return
        
    eqclient_path = os.path.join(zeal_dir, 'eqclient.ini')
    
    try:
        config = configparser.ConfigParser()
        config.optionxform = str
        config.read(eqclient_path)
        
        if 'KeyMaps' not in config:
            config['KeyMaps'] = {}
            
        keymaps = {
            'KEYMAP_FORWARD': 'w',
            'KEYMAP_BACK': 's',
            'KEYMAP_RIGHT': 'd',
            'KEYMAP_LEFT': 'a',
            'KEYMAP_AUTOPRIM': 'q',
            'KEYMAP_DUCK': 'e',
            'KEYMAP_AUTORUN': '\\',
            'KEYMAP_CycleTargetNPC': 'TAB',
            'KEYMAP_CycleTargetPC': '`',
            'KEYMAP_OpenCloseContainers': 'b'
        }
        
        for key, value in keymaps.items():
            config['KeyMaps'][key] = value
            
        with open(eqclient_path, 'w') as configfile:
            config.write(configfile)
            
        log_message("Applied WASD+ shortcut modifications to eqclient.ini", "green")
        
        # Show the modern dialog
        ShortcutsDialog(root)
        
    except Exception as e:
        log_message(f"Error applying WASD shortcuts: {str(e)}", "red")
        messagebox.showerror("Error", f"Failed to apply WASD shortcuts: {str(e)}")

def open_advanced_configurator():
    if not zeal_dir_entry.get():
        messagebox.showerror("Error", "Please select your Zeal directory first.")
        return
    try:
        configurator = AdvancedConfiguratorWindow(root, zeal_dir_entry.get())
        print("Advanced Configurator window opened successfully")
    except Exception as e:
        print(f"Error opening Advanced Configurator: {str(e)}")
        print(traceback.format_exc())
        messagebox.showerror("Error", f"Failed to open Advanced Configurator: {str(e)}")

def load_settings():
    if os.path.exists(settings_file):
        with open(settings_file, 'r') as f:
            settings = json.load(f)
            if "show_welcome" not in settings:
                settings["show_welcome"] = True
            return settings
    return {"show_welcome": True}

def save_settings(settings):
    with open(settings_file, 'w') as f:
        json.dump(settings, f)

def fetch_versions(github_repo):
    api_url = f"https://api.github.com/repos/{github_repo}/releases"
    response = requests.get(api_url)
    if response.status_code == 200:
        return [release['tag_name'] for release in response.json()]
    return []

def check_for_updates(github_repo, current_version, notice_label):
    api_url = f"https://api.github.com/repos/{github_repo}/releases/latest"
    response = requests.get(api_url)
    if response.status_code == 200:
        latest_version = response.json()['tag_name']
        if latest_version != current_version:
            notice_label.config(text=f"Latest Version: {latest_version}", fg="red")
        else:
            notice_label.config(text="", fg="black")
    else:
        notice_label.config(text="Failed to check for updates", fg="red")

def log_message(message, color):
    log_widget.config(state=tk.NORMAL)
    if color == "red":
        log_widget.tag_configure("red", foreground="red")
        log_widget.insert(tk.END, message + "\n", "red")
    elif color == "green":
        log_widget.tag_configure("green", foreground="green")
        log_widget.insert(tk.END, message + "\n", "green")
    else:
        log_widget.insert(tk.END, message + "\n")
    log_widget.config(state=tk.DISABLED)
    log_widget.see(tk.END)
    log_widget.update()

def check_and_update(project_name, version, github_repo, install_dir, log_widget):
    try:
        api_url = f"https://api.github.com/repos/{github_repo}/releases/tags/{version}"
        response = requests.get(api_url)
        if response.status_code == 200:
            download_url = response.json()['assets'][0]['browser_download_url']
            download_path = os.path.join(install_dir, "temp.zip")
            r = requests.get(download_url, stream=True)
            with open(download_path, 'wb') as f:
                shutil.copyfileobj(r.raw, f)

            with zipfile.ZipFile(download_path, 'r') as zip_ref:
                zip_ref.extractall(install_dir)

            os.remove(download_path)
            log_message(f"Updated {project_name} to version {version}", "green")
            return True
        else:
            log_message(f"Failed to fetch release info for {project_name}", "red")
            return False
    except Exception as e:
        log_message(f"Error updating {project_name}: {str(e)}", "red")
        return False

def browse_directory(entry_widget):
    dir_path = filedialog.askdirectory()
    if dir_path:
        entry_widget.delete(0, tk.END)
        entry_widget.insert(0, dir_path)
        save_current_settings()

def save_current_settings():
    settings = {
        "zeal_dir": zeal_dir_entry.get(),
        "quarmtool_dir": quarmtool_dir_entry.get(),
    }
    save_settings(settings)

def download_with_retry(url, path, max_retries=3):
    for attempt in range(max_retries):
        try:
            log_message(f"Downloading from {url} (Attempt {attempt + 1}/{max_retries})", "black")
            response = requests.get(url, stream=True)
            response.raise_for_status()
            
            total_size = int(response.headers.get('content-length', 0))
            block_size = 8192
            downloaded_size = 0
            
            with open(path, 'wb') as file:
                for chunk in response.iter_content(chunk_size=block_size):
                    if chunk:
                        file.write(chunk)
                        downloaded_size += len(chunk)
                        
                        if total_size > 0:
                            progress = (downloaded_size / total_size) * 100
                            log_message(f"Download progress: {progress:.2f}%", "black")
            
            log_message(f"Successfully downloaded to {path}", "green")
            return True
        
        except requests.exceptions.RequestException as e:
            log_message(f"Download attempt {attempt + 1} failed: {str(e)}", "red")
            if attempt == max_retries - 1:
                log_message(f"Max retries reached. Download failed.", "red")
                return False
            
            wait_time = 2 ** attempt
            log_message(f"Retrying in {wait_time} seconds...", "black")
            time.sleep(wait_time)
    
    return False

def install_ui_files():
    zeal_dir = zeal_dir_entry.get()
    ui_files_to_install = []
    
    if zeal_dir == "":
        messagebox.showerror("Error", "Please enter an EQ directory to install UI Files.")
        return

    status_window = UIInstallationStatus(root)

    ui_files = [
        {"name": "Nillipuss UI 1080p", "url": "https://api.github.com/repos/NilliP/NillipussUI_1080p/releases/latest", "var": nillipuss_1080p_var},
        {"name": "Nillipuss UI 1440p", "url": "https://api.github.com/repos/NilliP/NillipussUI_1440p/releases/latest", "var": nillipuss_1440p_var},
        {"name": "QRustle 1080p", "url": "https://github.com/user-attachments/files/17566105/Qrustle1080-Z5x.zip", "var": qrustle_1080p_var},
        {"name": "QRustle 1440p", "url": "https://github.com/user-attachments/files/17566110/Qrustle1440-Z5x.zip", "var": qrustle_1440p_var},
        {"name": "DuxaUI", "url": "https://github.com/LordDemonos/Quarm.Guide/blob/master/assets/duxaUI.7z?raw=true", "var": duxaui_var},
        {"name": "qqui (Calmethar Edition)", "url": "https://drive.google.com/uc?id=13aisHiN9kOkFJHywZnGUF0EfUOiq-jwx", "var": qqui_var},
        {"name": "d3pda UI", "url": "https://api.github.com/repos/defaultex/d3pda-quarm/releases/latest", "var": d3pda_var}
    ]

    total_files = sum(1 for ui_file in ui_files if ui_file["var"].get())
    files_processed = 0

    for ui_file in ui_files:
        if ui_file["var"].get():
            try:
                status_window.update_status(f"Processing {ui_file['name']}...")

                if ui_file["name"] == "qqui (Calmethar Edition)":
                    download_url = ui_file["url"]
                    file_extension = ".zip"
                elif ui_file["name"] == "DuxaUI":
                    download_url = ui_file["url"]
                    file_extension = ".7z"
                elif ui_file["name"].startswith("QRustle"):
                    download_url = ui_file["url"]
                    file_extension = ".zip"
                else:
                    try:
                        response = requests.get(ui_file["url"])
                        response.raise_for_status()
                        release_data = response.json()
                        if 'assets' in release_data and len(release_data['assets']) > 0:
                            download_url = release_data['assets'][0]['browser_download_url']
                        else:
                            raise ValueError(f"No assets found for {ui_file['name']}")
                        file_extension = ".zip"
                    except Exception as e:
                        log_message(f"Error fetching release info for {ui_file['name']}: {str(e)}", "red")
                        continue

                download_path = os.path.join(zeal_dir, "uifiles")
                os.makedirs(download_path, exist_ok=True)
                download_path = os.path.join(download_path, f"{ui_file['name']}{file_extension}")

                log_message(f"Downloading {ui_file['name']} from {download_url}", "black")
                r = requests.get(download_url, stream=True)
                r.raise_for_status()
                
                with open(download_path, 'wb') as f:
                    shutil.copyfileobj(r.raw, f)

                if file_extension == ".7z":
                    with py7zr.SevenZipFile(download_path, mode='r') as z:
                        z.extractall(os.path.join(zeal_dir, "uifiles"))
                elif file_extension == ".rar":
                    with rarfile.RarFile(download_path, 'r') as rf:
                        rf.extractall(os.path.join(zeal_dir, "uifiles/qqui"))
                else:
                    with zipfile.ZipFile(download_path, 'r') as zip_ref:
                        zip_ref.extractall(os.path.join(zeal_dir, "uifiles"))

                os.remove(download_path)
                ui_files_to_install.append(ui_file['name'])
                log_message(f"Installed {ui_file['name']} UI files to {zeal_dir}/uifiles", "green")

                files_processed += 1
                status_window.update_progress((files_processed / total_files) * 100)

            except Exception as e:
                log_message(f"Error installing {ui_file['name']} UI files: {str(e)}", "red")
                continue

    delete_equi_options_window(zeal_dir)

    if ui_files_to_install:
        messagebox.showinfo("Success", f"Installed UI files: {', '.join(ui_files_to_install)}")
    else:
        messagebox.showinfo("Information", "No UI files were installed.")

    status_window.update_status("Installation complete.")
    status_window.update_progress(100)
    status_window.destroy()

def delete_uifiles_zeal(zeal_dir):
    uifiles_zeal_path = os.path.join(zeal_dir, 'uifiles', 'zeal')
    if os.path.exists(uifiles_zeal_path):
        try:
            shutil.rmtree(uifiles_zeal_path)
            log_message(f"Deleted {uifiles_zeal_path}", "green")
        except Exception as e:
            log_message(f"Error deleting {uifiles_zeal_path}: {str(e)}", "red")
    else:
        log_message(f"{uifiles_zeal_path} does not exist. No deletion needed.", "black")

def delete_equi_options_window(zeal_dir):
    main_zeal_dir = zeal_dir
    file_to_delete = os.path.join(main_zeal_dir, 'EQUI_OptionsWindow.html')
    
    if os.path.exists(file_to_delete):
        try:
            os.remove(file_to_delete)
            log_message(f"Deleted {file_to_delete}", "green")
        except Exception as e:
            log_message(f"Error deleting {file_to_delete}: {str(e)}", "red")
    
    uifiles_dir = os.path.join(main_zeal_dir, 'uifiles')
    for root, dirs, files in os.walk(uifiles_dir):
        if root != os.path.join(uifiles_dir, 'zeal'):
            if 'EQUI_OptionsWindow.html' in files:
                file_to_delete = os.path.join(root, 'EQUI_OptionsWindow.html')
                try:
                    os.remove(file_to_delete)
                    log_message(f"Deleted {file_to_delete}", "green")
                except Exception as e:
                    log_message(f"Error deleting {file_to_delete}: {str(e)}", "red")

def update_zeal():
    zeal_dir = zeal_dir_entry.get()
    log_message("Starting update process for Zeal...", "black")
    
    # Preserve custom TGA files before deletion
    preserved_files = preserve_custom_tga_files(zeal_dir)
    
    # Delete the /uifiles/zeal folder before updating
    delete_uifiles_zeal(zeal_dir)
    
    zeal_version = zeal_version_var.get()
    zeal_updated = check_and_update("Zeal", zeal_version, "iamclint/Zeal", zeal_dir, log_widget)
    
    # Restore custom TGA files after update
    restore_custom_tga_files(zeal_dir, preserved_files)
    
    if not zeal_updated:
        log_message("Zeal is already up to date.", "green")

    # Call the function to delete EQUI_OptionsWindow.html after updating Zeal
    delete_equi_options_window(zeal_dir)

def update_quarmtool():
    zeal_dir = zeal_dir_entry.get()
    quarmtool_dir = quarmtool_dir_entry.get()

    if quarmtool_dir == zeal_dir:
        messagebox.showerror("Error", "QuarmTool cannot be installed in the main EQ directory. Please choose another location.")
        log_message("QuarmTool cannot be installed in the main EQ directory. Please choose another location.", "red")
        return

    log_message("Starting update process for QuarmTool...", "black")
    quarmtool_version = quarmtool_version_var.get()
    quarmtool_updated = check_and_update("QuarmTool", quarmtool_version, "EJWellman/QuarmTool", quarmtool_dir, log_widget)

    if not quarmtool_updated:
        log_message("QuarmTool is already up to date.", "green")

def update_all():
    """
    Updates Zeal and QuarmTool components.
    """
    log_message("Starting update process for all components...", "black")
    
    update_zeal()
    update_quarmtool()
    
    log_message("Completed updating Zeal and QuarmTool", "green")

def run_quarmtool():
    quarmtool_dir = quarmtool_dir_entry.get()
    if not quarmtool_dir:
        messagebox.showerror("Error", "QuarmTool directory is not set. Please set the directory before running QuarmTool.")
        return
    
    quarmtool_path = os.path.join(quarmtool_dir, "QuarmTool.exe")
    if not os.path.exists(quarmtool_path):
        messagebox.showerror("Error", "QuarmTool.exe not found in the specified directory.")
        return
    
    try:
        subprocess.Popen(quarmtool_path, cwd=quarmtool_dir)
        log_message("Started QuarmTool", "green")
    except Exception as e:
        messagebox.showerror("Error", f"Failed to run QuarmTool: {str(e)}")
        log_message(f"Error running QuarmTool: {str(e)}", "red")

def install_quarm_patcher():
    zeal_dir = zeal_dir_entry.get()
    if not zeal_dir:
        messagebox.showerror("Error", "Please select your Project Quarm directory first.")
        return

    try:
        # Download URL for the Quarm Patcher zip file
        download_url = "https://drive.google.com/uc?id=1IGVKZ3l9tdP3SvXLYhwLuHxRToqU8msF"
        download_path = os.path.join(zeal_dir, "quarm_patcher.zip")

        log_message("Downloading Quarm Patcher...", "black")
        
        # Download the file
        response = requests.get(download_url)
        with open(download_path, 'wb') as f:
            f.write(response.content)

        # Extract the contents to the Zeal directory
        with zipfile.ZipFile(download_path, 'r') as zip_ref:
            zip_ref.extractall(zeal_dir)

        # Clean up the zip file
        os.remove(download_path)
        
        log_message("Successfully installed Quarm Patcher", "green")
        messagebox.showinfo("Success", "Quarm Patcher has been installed successfully!")
        
    except Exception as e:
        log_message(f"Error installing Quarm Patcher: {str(e)}", "red")
        messagebox.showerror("Error", f"Failed to install Quarm Patcher: {str(e)}")

def run_quarm_patcher():
    zeal_dir = zeal_dir_entry.get()
    if not zeal_dir:
        messagebox.showerror("Error", "Zeal directory is not set. Please set the directory before running Quarm Patcher.")
        return
    
    patcher_path = os.path.join(zeal_dir, "eqemupatcher.exe")
    if not os.path.exists(patcher_path):
        messagebox.showerror("Error", "eqemupatcher.exe not found. Please install Quarm Patcher first.")
        return
    
    try:
        subprocess.Popen(patcher_path, cwd=zeal_dir)
        log_message("Started Quarm Patcher", "green")
    except Exception as e:
        messagebox.showerror("Error", f"Failed to run Quarm Patcher: {str(e)}")
        log_message(f"Error running Quarm Patcher: {str(e)}", "red")

def run_project_quarm():
    zeal_dir = zeal_dir_entry.get()
    if not zeal_dir:
        messagebox.showerror("Error", "Zeal directory is not set. Please set the directory before running Project Quarm.")
        return
    
    eqgame_path = os.path.join(zeal_dir, "eqgame.exe")
    if not os.path.exists(eqgame_path):
        messagebox.showerror("Error", "eqgame.exe not found in the specified Zeal directory.")
        return
    
    try:
        os.chdir(zeal_dir)
        subprocess.Popen(eqgame_path)
        log_message("Started Project Quarm", "green")
    except Exception as e:
        messagebox.showerror("Error", f"Failed to run Project Quarm: {str(e)}")
        log_message(f"Error running Project Quarm: {str(e)}", "red")

def is_process_running(process_name):
    """
    Check if a process with the given name is running from the correct directory.
    Now allows up to 2 instances of Project Quarm.
    """
    try:
        zeal_dir = os.path.normpath(zeal_dir_entry.get()).lower()
        count = 0
        
        for proc in psutil.process_iter(['name']):
            try:
                if proc.info['name'].lower() == process_name.lower():
                    try:
                        process = psutil.Process(proc.pid)
                        
                        if process_name.lower() == 'eqgame.exe':
                            try:
                                proc_path = os.path.normpath(process.exe()).lower()
                                expected_path = os.path.normpath(os.path.join(zeal_dir, 'eqgame.exe')).lower()
                                
                                if proc_path == expected_path:
                                    count += 1
                                    if count >= 2:  # Allow up to 2 instances
                                        return True
                            except (psutil.NoSuchProcess, psutil.AccessDenied):
                                continue
                        else:
                            return True
                            
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        continue
                        
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                continue
                
    except Exception as e:
        log_message(f"Error checking if process {process_name} is running: {str(e)}", "red")
        
    return False

def optimize_settings():
    zeal_dir = zeal_dir_entry.get()
    if not zeal_dir:
        messagebox.showerror("Error", "In order to optimize settings, you must first select your Zeal directory. This should be your main TAKP/EQ folder.")
        return
    
    eqclient_path = os.path.join(zeal_dir, 'eqclient.ini')
    
    if not os.path.exists(eqclient_path):
        messagebox.showerror("Error", "eqclient.ini file not found in the selected directory.")
        return
    
    config = configparser.ConfigParser()
    config.optionxform = str
    config.read(eqclient_path)
    
    settings_to_optimize = {
        'WindowedMode': 'FALSE',
        'NewUI': 'TRUE',
        'OldUI': 'FALSE',
        'Log': 'TRUE',
        'CombatMusic': 'TRUE',
        'AttackOnAssist': 'FALSE',
        'EnableExtendedNameplateDistance': 'TRUE',
        'BitsPerPixel': '32',
        'RefreshRate': '60',
        'User_70_Red': '0',
        'User_70_Green': '133',
        'User_70_Blue': '240',
        'MaxFPS': '60',
        'MaxBGFPS': '45',
        'MaxMouseLookFPS': '60',
        'ChatTimestamps': '2',
        'Bluecon': 'TRUE',
        'ZealInput': 'TRUE',
        'FloatingDamage': 'TRUE'
    }
    
    for section in config.sections():
        for key, value in settings_to_optimize.items():
            if config.has_option(section, key):
                config.set(section, key, value)
    
    config['VideoMode']['Width'] = str(root.winfo_screenwidth())
    config['VideoMode']['Height'] = str(root.winfo_screenheight())
    
    if 'Options' not in config:
        config['Options'] = {}
    config['Options']['NoFPSLimiter'] = '1'
    
    with open(eqclient_path, 'w') as configfile:
        config.write(configfile)
    
    log_message("Settings have been optimized", "green")
    messagebox.showinfo("Optimization Complete", "Your settings have been optimized.")

# Create the main window
if __name__ == "__main__":
    root = tk.Tk()
    root.title("Quarm+ v8.4")
    root.geometry("500x900")

    # Load saved settings
    settings = load_settings()

    # Directory input fields
    header_font = ('Helvetica', 12)

    tk.Label(root, text="Zeal Directory:", font=header_font).pack()
    zeal_dir_frame = tk.Frame(root)
    zeal_dir_frame.pack()
    zeal_dir_entry = tk.Entry(zeal_dir_frame, width=50)
    zeal_dir_entry.pack(side=tk.LEFT)
    zeal_dir_button = tk.Button(zeal_dir_frame, text="Browse", command=lambda: browse_directory(zeal_dir_entry))
    zeal_dir_button.pack(side=tk.LEFT)
    zeal_notice = tk.Label(zeal_dir_frame, text="")
    zeal_notice.pack(side=tk.LEFT, padx=10)

    # Zeal version dropdown
    tk.Label(root, text="Select Zeal Version:").pack()
    zeal_version_var = tk.StringVar(root)
    zeal_versions = fetch_versions("iamclint/Zeal")
    if zeal_versions:
        zeal_version_var.set(zeal_versions[0])
    zeal_version_dropdown = tk.OptionMenu(root, zeal_version_var, *zeal_versions)
    zeal_version_dropdown.pack()

    if "zeal_dir" in settings:
        zeal_dir_entry.insert(0, settings["zeal_dir"])

    tk.Label(height=1).pack()

    tk.Label(root, text="QuarmTool Directory:", font=header_font).pack()
    quarmtool_dir_frame = tk.Frame(root)
    quarmtool_dir_frame.pack()
    quarmtool_dir_entry = tk.Entry(quarmtool_dir_frame, width=50)
    quarmtool_dir_entry.pack(side=tk.LEFT)
    quarmtool_dir_button = tk.Button(quarmtool_dir_frame, text="Browse", command=lambda: browse_directory(quarmtool_dir_entry))
    quarmtool_dir_button.pack(side=tk.LEFT)
    quarmtool_notice = tk.Label(quarmtool_dir_frame, text="")
    quarmtool_notice.pack(side=tk.LEFT, padx=10)

    # QuarmTool version dropdown
    tk.Label(root, text="Select QuarmTool Version:").pack()
    quarmtool_version_var = tk.StringVar(root)
    quarmtool_versions = fetch_versions("EJWellman/QuarmTool")
    if quarmtool_versions:
        quarmtool_version_var.set(quarmtool_versions[0])
    quarmtool_version_dropdown = tk.OptionMenu(root, quarmtool_version_var, *quarmtool_versions)
    quarmtool_version_dropdown.pack()

    if "quarmtool_dir" in settings:
        quarmtool_dir_entry.insert(0, settings["quarmtool_dir"])

    # Create top buttons frame
    top_buttons_frame = tk.Frame(root)
    top_buttons_frame.pack(pady=5)

    update_zeal_button = tk.Button(top_buttons_frame, text="Update/Install Zeal", command=update_zeal)
    update_zeal_button.pack(side=tk.LEFT, padx=5)

    update_quarmtool_button = tk.Button(top_buttons_frame, text="Update/Install QuarmTool", command=update_quarmtool)
    update_quarmtool_button.pack(side=tk.LEFT, padx=5)

    install_patcher_button = tk.Button(top_buttons_frame, text="Install Quarm Patcher", command=install_quarm_patcher)
    install_patcher_button.pack(side=tk.LEFT, padx=5)

    # Create all buttons frame
    all_buttons_frame = tk.Frame(root)
    all_buttons_frame.pack(pady=5)

    update_all_button = tk.Button(all_buttons_frame, text="Update/Install Zeal+QT", 
                                 command=update_all, height=1, font=("bold"))
    update_all_button.pack(side=tk.LEFT, padx=5)

    separator = tk.Frame(root, height=2, bd=1, relief=tk.SUNKEN, bg="lightgray")
    separator.pack(fill=tk.X, padx=10, pady=10)

# UI Installation section
    tk.Label(root, text="Install Custom UI's:", font=header_font).pack()
    ui_checkboxes_frame = tk.Frame(root)
    ui_checkboxes_frame.pack(pady=5)

    nillipuss_1080p_var = tk.BooleanVar()
    tk.Checkbutton(ui_checkboxes_frame, text="Nillipuss UI 1080p", 
                   variable=nillipuss_1080p_var).pack(anchor=tk.W)

    nillipuss_1440p_var = tk.BooleanVar()
    tk.Checkbutton(ui_checkboxes_frame, text="Nillipuss UI 1440p", 
                   variable=nillipuss_1440p_var).pack(anchor=tk.W)

    qrustle_1080p_var = tk.BooleanVar()
    tk.Checkbutton(ui_checkboxes_frame, text="QRustle 1080p", 
                   variable=qrustle_1080p_var).pack(anchor=tk.W)

    qrustle_1440p_var = tk.BooleanVar()
    tk.Checkbutton(ui_checkboxes_frame, text="QRustle 1440p", 
                   variable=qrustle_1440p_var).pack(anchor=tk.W)

    duxaui_var = tk.BooleanVar()
    tk.Checkbutton(ui_checkboxes_frame, text="DuxaUI", 
                   variable=duxaui_var).pack(anchor=tk.W)

    qqui_var = tk.BooleanVar()
    tk.Checkbutton(ui_checkboxes_frame, text="qqui (Calmethar Edition)", 
                   variable=qqui_var).pack(anchor=tk.W)

    d3pda_var = tk.BooleanVar()
    tk.Checkbutton(ui_checkboxes_frame, text="d3pda UI", 
                   variable=d3pda_var).pack(anchor=tk.W)

    update_ui_button = tk.Button(root, text="Update/Install Selected UI Files", command=install_ui_files)
    update_ui_button.pack(pady=5)

    separator = tk.Frame(root, height=2, bd=1, relief=tk.SUNKEN, bg="lightgray")
    separator.pack(fill=tk.X, padx=10, pady=10)

    # Settings section
    tk.Label(root, text="Settings:", font=header_font).pack()
    settings_buttons_frame = tk.Frame(root)
    settings_buttons_frame.pack(pady=5)

    optimize_button = tk.Button(settings_buttons_frame, text="Apply Suggested Settings", 
                              command=optimize_settings)
    optimize_button.pack(side=tk.LEFT, padx=5)

    wasd_button = tk.Button(settings_buttons_frame, text="WASD+Shortcut Mods", 
                           command=apply_wasd_shortcuts)
    wasd_button.pack(side=tk.LEFT, padx=5)

    advanced_config_button = tk.Button(settings_buttons_frame, text="Advanced Configurator", 
                                     command=open_advanced_configurator)
    advanced_config_button.pack(side=tk.LEFT, padx=5)

    separator = tk.Frame(root, height=2, bd=1, relief=tk.SUNKEN, bg="lightgray")
    separator.pack(fill=tk.X, padx=10, pady=10)

    # Play section
    tk.Label(root, text="Play:", font=header_font).pack()
    play_buttons_frame = tk.Frame(root)
    play_buttons_frame.pack(pady=5)

    run_quarmtool_button = tk.Button(play_buttons_frame, text="Run QuarmTool", 
                                    command=run_quarmtool)
    run_quarmtool_button.pack(side=tk.LEFT, padx=5)

    run_project_quarm_button = tk.Button(play_buttons_frame, text="Run Project Quarm", 
                                       command=run_project_quarm)
    run_project_quarm_button.pack(side=tk.LEFT, padx=5)

    run_patcher_button = tk.Button(play_buttons_frame, text="Run Quarm Patcher", 
                                  command=run_quarm_patcher)
    run_patcher_button.pack(side=tk.LEFT, padx=5)

    # Log frame
    log_frame = tk.Frame(root)
    log_frame.pack(fill=tk.BOTH, expand=True)

    log_widget = tk.Text(log_frame, width=70, height=10, wrap=tk.WORD)
    log_scrollbar = tk.Scrollbar(log_frame, orient="vertical", command=log_widget.yview)

    log_widget.configure(yscrollcommand=log_scrollbar.set)
    log_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    log_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    log_widget.tag_configure("red", foreground="red")
    log_widget.tag_configure("green", foreground="green")
    log_widget.tag_configure("black", foreground="black")

    # Bind settings save events
    zeal_dir_entry.bind("<FocusOut>", lambda e: save_current_settings())
    quarmtool_dir_entry.bind("<FocusOut>", lambda e: save_current_settings())

    # Check for updates when the app starts
    check_for_updates("iamclint/Zeal", zeal_version_var.get(), zeal_notice)
    check_for_updates("EJWellman/QuarmTool", quarmtool_version_var.get(), quarmtool_notice)

    # Run the main loop
    root.mainloop()
